"use client"

import { useState, useEffect } from "react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { Badge } from "@/components/ui/badge"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { ScrollArea } from "@/components/ui/scroll-area"
import { Input } from "@/components/ui/input"
import { Skeleton } from "@/components/ui/skeleton"
import { FileText, Mic, CheckCircle, AlertCircle, RefreshCw, Calendar, User, ChevronDown, ChevronUp, Search, Clock, Copy, Play, Pause } from "lucide-react"
import { cn } from "@/lib/utils"
import { createClientComponentClient } from '@supabase/auth-helpers-nextjs'

interface TranscriptSegment {
  speaker: string
  text: string
  start_time: number
  end_time: number
}

interface Meeting {
  id: string
  deal_id: string
  meeting_id?: string
  title?: string
  summary: string
  highlights: string[]
  action_items: any[]
  transcript_url?: string
  recording_url?: string
  created_at: string
  start_time?: string
  end_time?: string
  participant_emails?: string[]
}

interface MeetingSummaryProps {
  dealId: string
  className?: string
}

export default function MeetingSummary({ dealId, className }: MeetingSummaryProps) {
  const [meetings, setMeetings] = useState<Meeting[]>([])
  const [loading, setLoading] = useState(true)
  const [selectedMeeting, setSelectedMeeting] = useState<string | null>(null)
  const [isTranscriptExpanded, setIsTranscriptExpanded] = useState(false)
  const [transcript, setTranscript] = useState<TranscriptSegment[]>([])
  const [transcriptLoading, setTranscriptLoading] = useState(false)
  const [searchQuery, setSearchQuery] = useState("")
  const [filteredTranscript, setFilteredTranscript] = useState<TranscriptSegment[]>([])
  const [transcriptError, setTranscriptError] = useState<string | null>(null)
  
  const supabase = createClientComponentClient()

  // Load meetings data on component mount
  useEffect(() => {
    fetchMeetings()
  }, [dealId])

  // Filter transcript when search query changes
  useEffect(() => {
    if (!searchQuery.trim()) {
      setFilteredTranscript(transcript)
      return
    }
    const query = searchQuery.toLowerCase()
    const filtered = transcript.filter((segment) => 
      segment.text.toLowerCase().includes(query) || 
      segment.speaker.toLowerCase().includes(query)
    )
    setFilteredTranscript(filtered)
  }, [searchQuery, transcript])

  const fetchMeetings = async () => {
    setLoading(true)
    try {
      console.log('ðŸ” Fetching meetings for deal:', dealId)
      
      // Get current user to ensure proper filtering
      const { data: { user }, error: userError } = await supabase.auth.getUser()
      if (userError || !user) {
        console.error('User not authenticated:', userError)
        setMeetings([])
        return
      }

      console.log('ðŸ‘¤ Current user:', user.email)

      // First, verify this deal belongs to the current user
      const { data: deal, error: dealError } = await supabase
        .from('deals')
        .select('id, company_name')
        .eq('id', dealId)
        .eq('user_id', user.id)
        .single()

      if (dealError || !deal) {
        console.error('Deal not found or not owned by user:', dealError)
        setMeetings([])
        return
      }

      console.log('âœ… Deal verified:', deal.company_name)

      let allMeetings: Meeting[] = []

      // 1. Fetch meetings from meetings table (processed meetings with transcripts)
      // Join with deals table to ensure proper user filtering
      const { data: meetingsData, error: meetingsError } = await supabase
        .from('meetings')
        .select(`
          *,
          deals!inner(id, user_id, company_name)
        `)
        .eq('deals.user_id', user.id)
        .eq('deal_id', dealId)
        .order('created_at', { ascending: false })

      console.log('ðŸ“… Meetings from meetings table:', { meetingsData, meetingsError })

      // 2. Fetch scheduled meetings from scheduled_meetings table
      const { data: scheduledMeetingsData, error: scheduledError } = await supabase
        .from('scheduled_meetings')
        .select('*')
        .eq('deal_id', dealId)
        .order('created_at', { ascending: false })

      console.log('ðŸ“… Scheduled meetings:', { scheduledMeetingsData, scheduledError })

      // 3. Convert meetings table data
      if (meetingsData && meetingsData.length > 0) {
        const convertedMeetings = meetingsData.map(meeting => ({
          id: meeting.id,
          deal_id: meeting.deal_id,
          meeting_id: meeting.meeting_id,
          title: meeting.title || 'Meeting',
          summary: meeting.summary || 'Meeting completed - processing insights',
          highlights: meeting.highlights || [],
          action_items: meeting.action_items || [],
          transcript_url: meeting.transcript_url,
          recording_url: meeting.recording_url,
          created_at: meeting.created_at,
          start_time: meeting.start_time,
          end_time: meeting.end_time,
          participant_emails: meeting.participant_emails || []
        }))
        allMeetings.push(...convertedMeetings)
      }

      // 4. Convert scheduled meetings data
      if (scheduledMeetingsData && scheduledMeetingsData.length > 0) {
        const convertedScheduled = scheduledMeetingsData.map(scheduled => ({
          id: scheduled.id,
          deal_id: scheduled.deal_id,
          meeting_id: scheduled.meetgeek_meeting_id, // Use MeetGeek meeting ID if available
          title: scheduled.meeting_title || 'Scheduled Meeting',
          summary: 'Meeting scheduled - transcript will be available after completion',
          highlights: [],
          action_items: [],
          transcript_url: scheduled.meetgeek_meeting_id ? `meetgeek://${scheduled.meetgeek_meeting_id}` : undefined,
          recording_url: undefined,
          created_at: scheduled.created_at,
          start_time: scheduled.start_time,
          end_time: scheduled.end_time,
          participant_emails: scheduled.attendees?.map((a: any) => a.email) || []
        }))
        allMeetings.push(...convertedScheduled)
      }

      // 5. Sort meetings: prioritize those with transcripts, then by date
      allMeetings.sort((a, b) => {
        // First, prioritize meetings with transcripts
        const aHasTranscript = !!(a.meeting_id && a.meeting_id !== 'null')
        const bHasTranscript = !!(b.meeting_id && b.meeting_id !== 'null')
        
        if (aHasTranscript && !bHasTranscript) return -1
        if (!aHasTranscript && bHasTranscript) return 1
        
        // If both have transcripts or both don't, sort by date (most recent first)
        return new Date(b.created_at).getTime() - new Date(a.created_at).getTime()
      })

      console.log('âœ… Final meetings list:', allMeetings)
      setMeetings(allMeetings)
    } catch (error) {
      console.error('Error fetching meetings:', error)
      setMeetings([])
    } finally {
      setLoading(false)
    }
  }

  const fetchTranscript = async (meeting: Meeting) => {
    setTranscriptLoading(true)
    setTranscriptError(null)
    try {
      console.log('ðŸŽ¯ fetchTranscript called with meeting:', meeting)
      
      // Only attempt to fetch real transcript data if we have a meeting_id
      if (meeting.meeting_id && meeting.meeting_id !== 'null') {
        console.log('ðŸŽ¯ Fetching real transcript for meeting ID:', meeting.meeting_id)
        
        const response = await fetch(`/api/transcripts/${meeting.meeting_id}`)
        const result = await response.json()

        console.log('ðŸ“ Transcript API result:', result)

        if (response.ok && result.success && result.transcript?.length > 0) {
          console.log(`âœ… Found ${result.transcript.length} unique transcript segments`)
          
          const meetingData = result.meeting
          
          // Convert database transcript to our format with better speaker names
          const realTranscript: TranscriptSegment[] = result.transcript.map((segment: any, index: number) => {
            // Parse timestamp to get seconds from start
            const timestamp = new Date(segment.timestamp)
            const meetingStart = new Date(result.transcript[0].timestamp)
            const secondsFromStart = Math.max(0, (timestamp.getTime() - meetingStart.getTime()) / 1000)
            
            // Improve speaker identification
            let speakerName = segment.speaker
            if (segment.speaker === 'Unknown speaker' || !segment.speaker) {
              // Use participant emails to create better speaker names
              if (meetingData?.participant_emails?.length > 0) {
                const speakerIndex = Math.floor(index / 5) % meetingData.participant_emails.length
                const email = meetingData.participant_emails[speakerIndex]
                speakerName = email === 'tim@vellora.ai' ? 'Timothy Lefkowitz' : 
                             email === 'matt@vellora.ai' ? 'Matt' : 
                             email.split('@')[0].charAt(0).toUpperCase() + email.split('@')[0].slice(1)
              } else {
                speakerName = `Speaker ${Math.floor(index / 5) + 1}`
              }
            }
            
            return {
              speaker: speakerName,
              text: segment.transcript,
              start_time: secondsFromStart,
              end_time: secondsFromStart + 5 // Estimate 5 seconds per segment
            }
          })

          console.log(`ðŸŽ¤ Processed transcript with ${realTranscript.length} segments:`, realTranscript.slice(0, 3))
          console.log('ðŸŽ¤ Setting transcript state with real data')
          setTranscript(realTranscript)
          setFilteredTranscript(realTranscript)
          return
        } else {
          console.log('âš ï¸ No transcript data found via API')
          console.log('API response:', result)
          setTranscriptError('No transcript data available for this meeting')
          setTranscript([])
          setFilteredTranscript([])
          return
        }
      } else {
        console.log('âš ï¸ No meeting_id available for transcript fetch')
        setTranscriptError('No transcript available for this meeting')
        setTranscript([])
        setFilteredTranscript([])
        return
      }
    } catch (error) {
      console.error('Error fetching transcript:', error)
      setTranscriptError('Failed to load transcript data')
      setTranscript([])
      setFilteredTranscript([])
    } finally {
      setTranscriptLoading(false)
    }
  }

  const formatDate = (dateString: string) => {
    return new Date(dateString).toLocaleDateString("en-US", {
      month: "short",
      day: "numeric",
      year: "numeric",
      hour: "2-digit",
      minute: "2-digit",
    })
  }

  const formatTime = (seconds: number) => {
    const minutes = Math.floor(seconds / 60)
    const remainingSeconds = Math.floor(seconds % 60)
    return `${minutes}:${remainingSeconds.toString().padStart(2, "0")}`
  }

  const handleViewTranscript = async (meeting: Meeting) => {
    if (isTranscriptExpanded) {
      setIsTranscriptExpanded(false)
      setTranscript([])
      setSearchQuery("")
      setTranscriptError(null)
    } else {
      setIsTranscriptExpanded(true)
      await fetchTranscript(meeting)
    }
  }

  const highlightSearchText = (text: string) => {
    if (!searchQuery.trim()) return text
    const query = searchQuery.toLowerCase()
    const parts = text.split(new RegExp(`(${query})`, "gi"))
    return parts.map((part, i) =>
      part.toLowerCase() === query.toLowerCase() ? (
        <span key={i} className="bg-designer-violet/30 text-white font-medium">
          {part}
        </span>
      ) : (
        part
      )
    )
  }

  if (loading && meetings.length === 0) {
    return (
      <Card className={cn("bg-black/40 border-white/10", className)}>
        <CardContent className="flex items-center justify-center py-8">
          <RefreshCw className="h-6 w-6 animate-spin text-designer-violet" />
        </CardContent>
      </Card>
    )
  }

  if (meetings.length === 0) {
    return (
      <Card className={cn("bg-black/40 border-white/10", className)}>
        <CardContent className="text-center py-8">
          <Mic className="h-12 w-12 text-white/20 mx-auto mb-3" />
          <p className="text-white/50 text-sm">No meeting data available yet</p>
        </CardContent>
      </Card>
    )
  }

  const latestMeeting = meetings[0]
  const currentMeeting = selectedMeeting ? meetings.find((m) => m.id === selectedMeeting) : latestMeeting

  return (
    <Card className={cn("bg-black/40 border-white/10", className)}>
      <CardHeader>
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            <Mic className="h-5 w-5 text-designer-violet" />
            <CardTitle className="text-lg">Meeting Insights</CardTitle>
          </div>
          <Badge variant="outline" className="text-xs">
            {meetings.length} meeting{meetings.length !== 1 ? "s" : ""}
          </Badge>
        </div>

      </CardHeader>
      <CardContent>
        {meetings.length > 1 && (
          <div className="mb-4">
            <ScrollArea className="w-full h-20">
              <div className="flex flex-col gap-2 pr-4">
                {meetings.map((meeting) => {
                  const hasTranscript = !!(meeting.meeting_id && meeting.meeting_id !== 'null')
                  return (
                    <Button
                      key={meeting.id}
                      variant={currentMeeting?.id === meeting.id ? "default" : "outline"}
                      size="sm"
                      className={cn(
                        "w-full justify-start text-xs",
                        hasTranscript && "border-designer-violet/50 bg-designer-violet/10"
                      )}
                      onClick={() => setSelectedMeeting(meeting.id)}
                    >
                      <Calendar className="h-3 w-3 mr-2" />
                      <span className="flex-1 text-left">{formatDate(meeting.created_at)}</span>
                      <span className="text-xs text-white/50 mr-2">{meeting.title}</span>
                      {hasTranscript && (
                        <FileText className="h-3 w-3 text-designer-violet" />
                      )}
                    </Button>
                  )
                })}
              </div>
            </ScrollArea>
          </div>
        )}

        <Tabs defaultValue="summary" className="w-full">
          <TabsList className="grid w-full grid-cols-3 bg-black/60">
            <TabsTrigger value="summary">Summary</TabsTrigger>
            <TabsTrigger value="highlights">Highlights</TabsTrigger>
            <TabsTrigger value="actions">Actions</TabsTrigger>
          </TabsList>

          <TabsContent value="summary" className="mt-4">
            <div className="space-y-3">
              <div className="bg-gray-800/50 rounded-lg p-4">
                <p className="text-sm text-white/80 leading-relaxed">
                  {currentMeeting?.summary || "No summary available"}
                </p>
              </div>
              {currentMeeting && (
                <>
                  {currentMeeting.meeting_id && currentMeeting.meeting_id !== 'null' ? (
                    <Button
                      variant="outline"
                      size="sm"
                      className="w-full border-designer-violet/50 hover:bg-designer-violet/10"
                      onClick={() => handleViewTranscript(currentMeeting)}
                    >
                      <FileText className="h-4 w-4 mr-2 text-designer-violet" />
                      {isTranscriptExpanded ? 'Hide Transcript' : 'View Full Transcript'}
                      {isTranscriptExpanded ? (
                        <ChevronUp className="h-4 w-4 ml-2" />
                      ) : (
                        <ChevronDown className="h-4 w-4 ml-2" />
                      )}
                    </Button>
                  ) : (
                    <div className="text-center py-3">
                      <p className="text-sm text-white/50">
                        Transcript will be available after meeting completion
                      </p>
                    </div>
                  )}
                </>
              )}
            </div>
          </TabsContent>

          <TabsContent value="highlights" className="mt-4">
            <div className="space-y-2">
              {currentMeeting?.highlights && currentMeeting.highlights.length > 0 ? (
                currentMeeting.highlights.map((highlight, index) => (
                  <div key={index} className="flex items-start gap-2 bg-designer-violet/10 rounded-lg p-3">
                    <AlertCircle className="h-4 w-4 text-designer-violet mt-0.5 shrink-0" />
                    <p className="text-sm text-white/80">{highlight}</p>
                  </div>
                ))
              ) : (
                <p className="text-sm text-white/50 text-center py-4">No highlights available</p>
              )}
            </div>
          </TabsContent>

          <TabsContent value="actions" className="mt-4">
            <div className="space-y-2">
              {currentMeeting?.action_items && currentMeeting.action_items.length > 0 ? (
                currentMeeting.action_items.map((item, index) => (
                  <div key={index} className="flex items-start gap-2 bg-green-500/10 rounded-lg p-3">
                    <CheckCircle className="h-4 w-4 text-green-400 mt-0.5 shrink-0" />
                    <div className="flex-1">
                      <p className="text-sm text-white/80">{item.text}</p>
                      {item.assignee && (
                        <div className="flex items-center gap-1 mt-1">
                          <User className="h-3 w-3 text-white/50" />
                          <span className="text-xs text-white/50">{item.assignee}</span>
                        </div>
                      )}
                    </div>
                  </div>
                ))
              ) : (
                <p className="text-sm text-white/50 text-center py-4">No action items available</p>
              )}
            </div>
          </TabsContent>
        </Tabs>

        {/* Inline Transcript Expansion */}
        {isTranscriptExpanded && (
          <div className="mt-6 border-t border-white/10 pt-6">
            <div className="flex items-center justify-between mb-4">
              <h3 className="text-lg font-semibold text-white">Meeting Transcript</h3>
              <div className="flex items-center gap-2">
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => {
                    const text = transcript.map(segment => `${segment.speaker}: ${segment.text}`).join('\n\n')
                    navigator.clipboard.writeText(text)
                  }}
                  disabled={transcript.length === 0}
                >
                  <Copy className="h-4 w-4 mr-1" />
                  Copy
                </Button>
                <div className="relative">
                  <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-400" />
                  <Input
                    value={searchQuery}
                    onChange={(e) => setSearchQuery(e.target.value)}
                    placeholder="Search transcript..."
                    className="pl-10 w-64 bg-gray-800 border-gray-700"
                    disabled={transcript.length === 0}
                  />
                </div>
              </div>
            </div>

            <ScrollArea className="h-96 pr-4">
              {transcriptLoading ? (
                <div className="space-y-4">
                  {Array.from({ length: 8 }).map((_, i) => (
                    <div key={i} className="flex gap-4">
                      <Skeleton className="h-10 w-10 rounded-full" />
                      <div className="space-y-2 flex-1">
                        <Skeleton className="h-4 w-32" />
                        <Skeleton className="h-4 w-full" />
                      </div>
                    </div>
                  ))}
                </div>
              ) : transcriptError ? (
                <div className="text-center py-8">
                  <FileText className="h-12 w-12 text-white/20 mx-auto mb-3" />
                  <p className="text-white/50 mb-2">{transcriptError}</p>
                  <p className="text-sm text-white/30">Transcript data may not be available for this meeting yet.</p>
                </div>
              ) : (
                <div className="space-y-4">
                  {filteredTranscript.length === 0 ? (
                    <div className="text-center py-8">
                      <FileText className="h-12 w-12 text-white/20 mx-auto mb-3" />
                      <p className="text-white/50">
                        {searchQuery ? 'No matching transcript segments found' : 'No transcript available'}
                      </p>
                    </div>
                  ) : (
                    filteredTranscript.map((segment, index) => (
                      <div key={index} className="flex gap-4 p-3 rounded-lg bg-gray-800/30 hover:bg-gray-800/50 transition-colors">
                        <div className="flex flex-col items-center gap-1">
                          <div className="h-10 w-10 rounded-full bg-designer-violet/20 flex items-center justify-center shrink-0">
                            <User className="h-5 w-5 text-designer-violet" />
                          </div>
                          <div className="text-xs text-gray-400 flex items-center gap-1">
                            <Clock className="h-3 w-3" />
                            {formatTime(segment.start_time)}
                          </div>
                        </div>
                        <div className="flex-1">
                          <div className="flex items-center gap-2 mb-1">
                            <span className="font-medium text-white">{segment.speaker}</span>
                            <span className="text-xs text-gray-400">
                              {formatTime(segment.start_time)} - {formatTime(segment.end_time)}
                            </span>
                          </div>
                          <p className="text-white/80 leading-relaxed">
                            {highlightSearchText(segment.text)}
                          </p>
                        </div>
                      </div>
                    ))
                  )}
                </div>
              )}
            </ScrollArea>
          </div>
        )}
      </CardContent>
    </Card>
  )
}
